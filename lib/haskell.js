// Generated by CoffeeScript 1.6.2
var f, include,
  __slice = [].slice;

f = module.exports = function(lambda) {
  var args, variable, _ref, _ref1;

  if (lambda == null) {
    lambda = "";
  }
  lambda = lambda.trim();
  args = ['x'];
  lambda = lambda.split(/\s*\-\>\s*/).filter(function(a) {
    return a !== "";
  });
  if (!lambda.single() && !lambda.empty()) {
    args = lambda[0].split(' ').filter(function(a) {
      return a !== "";
    });
  }
  if (lambda.single()) {
    args = ((_ref = lambda[0].match(/([a-z\_\$][\w\_\$]*)/ig)) != null ? _ref.unique() : void 0) || args;
  }
  lambda = ((_ref1 = lambda.pop()) != null ? _ref1.trim() : void 0) || "";
  variable = lambda.match(/([a-z\_\$][\w\_\$]*)/i) == null ? args[0] : "";
  return eval("(function(" + args + ") { return (" + variable + lambda + "); })");
};

String.lambda = String.toFunction = f.lambda = f;

Function.prototype.lambda = Function.prototype.toFunction = function() {
  return this;
};

String.prototype.lambda = String.prototype.toFunction = function() {
  return f(this);
};

Function.prototype.c = Function.prototype.curry = function() {
  var args;

  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return f.curry.apply(f, [this.toFunction()].concat(__slice.call(args)));
};

f.curry = f.c = function() {
  var args, fn;

  fn = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  return function() {
    var args2;

    args2 = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return fn.toFunction().apply(null, __slice.call(args).concat(__slice.call(args2)));
  };
};

include = function(m) {
  var k, v, _ref, _results;

  _ref = require("./haskell." + m);
  _results = [];
  for (k in _ref) {
    v = _ref[k];
    _results.push(f[k] = v);
  }
  return _results;
};

include('array');

include('sequence');
